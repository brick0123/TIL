# 1. 도메인 모델 시작

### 도메인

도메인은 여러 하위 도메인으로 구성할 수 있다. 한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 가능을 제공한다. ex) 고객이 물건을 구매하면 주문, 결제, 배송, 혜택 하위 도메인의 기능이 엮인다. 

특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야 할 모든 기능을 구현하는 것은 아니다.

### 도메인 모델 패턴

일반적인 아키텍처는 네 개의 계층으로 구성된다

**사용자인터페이스 또는 표현**

- 사용자의 요청을 처리하고 사용자에게 정보를 보여준다.

**응용**

- 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행시킨다.

**도메인**

- 시스템이 제공할 도메인의 규칙을 구현한다. (도메인의 핵슴 규칙을 구현한다

**인프라스트럭쳐**

- DB나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.

### 엔티티 식별자와 밸류 타입

엔티티 식발자의 Stringㄷ 같은 문자열로 구성 될 경우 밸류 타입을 이용해 의미가 잘 드러나도록 하라.

```java
public class Order {
    private String orderNo; // before
	// OrderNo 타입 자체로 id가 주문번호임을 알 수 있다.
	private OrderNo id;     // after    
}
```
</br>

# 2. 아키텍처 개요

## 네 개의 영역

- 표현: HTTP 요청을 응용 영역이 필요하는 형식으로 전달한고, 응용 영역의 응답을 HTTP 응답으로 변환하여 전송한다.
- 응용: 시스템이 사용자에게 제공해야될 기능을 구현한다. ex) "주문 등록", "주문 취소"
- 도메인: 도메인 모델을 구현한다. 도메인 모델은 도메인의 핵심 로직을 구현한다.
- 인프라스트럭처: 구현 기술에 대한 것을 다룬다. ex) DB, 메시징 큐 전송, 수신 ...

![st](../assets/DDD/ddd-1.png)

응용 계층은 유연하게 외부 시스템과의 연동을 위해 인프라스트럭처에 의존하기도 한다.
</br>
응용, 도메인 계층이 상세한 기술은 인프라스트럭처 계층에 종속되는데, "테스트", "기능 확장"의 문제가 발생한다.
</br>

이 문제는 이는 `DIP`를 이용하여 해결할 수 있다. 고수준 모듈(의미 있는 단일 기능을 제공)의 기능을 구현하려면 여러 하위 기능이 필요하다. 즉 고수준 모듈이 저수준 모듈을 사용해야하는데 `DIP`는 저수준 모듈이 고수준 모듈에 의존하도록 변경한다.
</br>

저수준 모듈에 직접 의존할 때는 헤당 모듈이 직접 만들어지기 전까지는 테스트하기가 힘들지만 인터페이스를 이용하므로 stub을 사용하여 테스트를 진행할 수 있다.

**주의 사항**
</br>
DIP는 인터페이스와 구현 클레스를 분리하는 정도로만 받아들일 수 있는데, 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.


### 도메인 영역의 주요 구성요소

|요소|설명|
|---|---|
|Entity| 고유 식별자로 갖는 객체. 도메인 모델의 데이터를 포함하여 해당 데이터와 관련된 로직을 제공한다
|Value| 고유 식별자를 갖지 않는 객체로 주로 개념적으로 하나의 도메인 객체의 속성을 표현하는데 사용|
|Aggreagte| 앤티티와 밸류 객체를 하나로 묶은 것|
|Repository| 도메인 모델의 영속성을 처리한다 |
|Domain Service| 특정 엔티티에 속하지 않은 도메인 로직을 제공. 도메인 로직이 여러 엔티티 밸류가 필요할 경우 도메인 서비스에서 로직을 구현한다|

### 모듈 구성

![m](../assets/DDD/ddd-4.jpg) </br>

[soruce](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=84000742)
</br>
영역별 별도 패키지로 구성한 모둘

![m](../assets/DDD/ddd-3.jpg)

[soruce](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=84000742)
</br>
domain 모듈은 도메인에 속한 애그리거트를 기준으로 패키지 재구성.

![m](../assets/DDD/ddd-2.jpg)


[soruce](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=84000742)
</br>
하위 도메인을 하위 패키지로 구성한 모듈 구조

도메인이 너무 복잡해지면 도메인 모델과 도메인 서비스를 나눌 수도 있다
- com.woodcock.order.domain.order: 애그리거트 위치
- com.woodcock.order.domain.service: 도메인 서비스 위치

---

## 3장 애그리거트

애그리거트의 경계는 도메인 규칙과 요구사항에 따라서 설정되며, 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 또한 A가 B를 갖는다고해서 무조건 한 애그리거트로 묶이는 것은 아니다. 대표적으로 상품과 리뷰가 있다. 이 둘은 함께 생성, 변경, 영향을 주지 않는다.

</br>

### 루트 애그리거트
루트 애그리거트란 애그리거트에 속한 모든 객체의 일관된 상태를 유지하도록 관리하는 주체이다. 애그리거트 루트가 제공하는 메소드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다. 다른 객체가 애그리거트에 속한 객체를 직접 변경하여 논리적인 데이터의 일관성을 깨뜨리는 일이 없도록 주의해야한다.
</br>

### 트랜잭션 범위

트랜잭션 범위는 가능한 작을 수록 좋다. 동일한 한 트랜잭션에서는 한 개의 애그리거트만 수정해야한다. 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지고 애그리거트 개수가 많을 수록 전체 처리량이 떨어진다. 물론 꼭 필요에 의해서 하는 경우는 제외다. 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아지고 향후 수정 비용이 증가한다.
</br>
두 개 이상의 애그리거트가 수정되어야 한다면 응요 서비스에서 두 애그리거트를 수정해야한다.
